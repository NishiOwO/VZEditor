第１１章 マクロ言語仕様

## １１.１ 概要

&emsp;VZのマクロ言語は、次のような特徴を備えています。

- 40種のCライクな演算子（push,pop,byte/word ptr等のオリジナル演算子を含む）
- 60個の汎用変数の他、オプション変数、システム変数を演算式で使用可能
- printf,int86,strchr,locate,rand 等のバライティ豊かなシステム関数
- DEFファイルで定義したポップアップメニューを呼び出し可能
- if..else.. on..goto.. に相当する条件分岐、ブロック、ループ制御構造
- 最大16レベルのネストおよびバックグラウンドでのマクロ実行が可能

&emsp;Ver1.6では、さらに次の機能を強化しました。

- ポインタ演算における制限を解消
- 文字列操作関数、ロング演算関数を追加
- モジュール管理関数「&z &Zd &Zs」
- 文字、行・ブロック削除時のバッファへの格納禁止オプション***ux***
- ブロック範囲の比較変数***xc***
- 選択したメニューのメッセージポインタ「***pm***」
- DOSコマンドをサイレントで実行する「***ss***=2」
- 複数のスイッチを一度にpush,popできるオプション「***Jd Je Js Jx Ju***」
- 汎用変数「***w ww fi fj***」の追加


## １１.２ キーワード

&emsp;VZのマクロコードは、次にあげる「キーワード」と、後で述べる「演算式」で構成されています。各々のキーワードの間は、スペース・タブ・改行で区切っても、続けて記述しても構いません。ただし、一つのキーワード中には、このような区切り文字を挿入してはなりません。

● **以下の書式中の「n，a，A」は、それぞれ「10進数，英小文字，英大文字」を表します。**<br>


#### "string"
&emsp;string をキーボードからの入力文字列とします。

#### 'c'
&emsp;cの1文字（半角／全角）をキーボードからの入力文字とします。

#### ＃nn ＃a ＃A
&emsp;nn番の基本コマンドを実行します。多くのコマンドは、番号の代りにより覚えやすい1文字の英文字または英記号で記述できます。（この文字は、ヘルプメニューでメッセージの前に表示されます）
&emsp;変数rには、コマンドの返り値をセットします。通常の返り値は次のとおりです。

	r == 0		: 正常終了
	r == -1		: 実行不可能／キャンセル／エラー等

&emsp;詳しくは、「付録A.基本コマンド一覧」を参照してください。

#### ！nn
&emsp;nn番のポップアップメニューを呼び出します。<br>　変数rには、次の値をセットします。

	r >= 0		: 選択したメニューアイテムの番号
	r == -1		: [**ESC**]
	★r < 0		: コマンドキーでキャンセル
&emsp;　　　	  b0～7:キーコード、b8～14:メニューアイテム番号<br>

#### ＆nn　＆＞　＆＊　＆＋n ＆－n
&emsp;指定マクロをコールします。（16レベルまでネスト可能）
&emsp;変数rには、呼び出したマクロで最後に(式)で評価した値をセットします。<br>　各々の書式の指定するマクロは、次のとおりです。

	&nn		: nn番のマクロ
	&>		: 次のマクロ
	&*		: 最後に組込んだマクロファイルのマクロ
	&+n &-n	: 現在実行中のマクロ番号±n番のマクロ

#### ＆a ＆a(...)
&emsp;システム関数をコールします。関数によっては、変数rに返り値をセットします。各々のシステム関数は、「11.4 システム関数」で説明します。

#### ★＆Aa ＆Aa(...)
&emsp;Ver1.6の拡張システム関数をコールします。関数によっては、変数rに返り値をセットします。また、一部の関数は、汎用変数「bx,cx,dx,si,di」に返り値をセットする関数もあります。<br>　※ 従来、システム関数のシンボルは大文字でもエラーになりませんでした。Ver1.6では、大文字の場合は2文字の拡張システム関数と認識されます。

#### ＆＃nn(...) ＆＃a(...) ＆＃A(...)
&emsp;基本コマンドの一部は、このように引数を持ってマクロから呼ぶことができます。これらのコマンドは、「コマンド関数」と呼びます。各々のコマンド関数は、「11.6 コマンド関数」で説明します。

#### ＞nn　＞＞　＞＊　＞＋n ＞－n
&emsp;指定マクロへジャンプします。各々の書式の内容は、コールの場合と同様です。

#### ＞＾
&emsp;実行中のマクロの先頭へジャンプします。

#### ＞A
&emsp;指定ラベルへジャンプします。

#### ：A
&emsp;ジャンプのラベルです。ラベルは1文字の英大文字で記述します。

#### .
&emsp;実行中のマクロを終了します。サブルーチンからのリターンに相当します。

#### ／
&emsp;マクロの実行を中止します。

#### （式）
&emsp;(...)内の演算式を評価し、結果を内部レジスタに格納します。

#### 式 ，
&emsp;キーワードが英字で始まった場合、それ以降、文末または「,（カンマ）」までを演算式として処理します。(式)の場合と異なり、式の値の評価は行ないません。

#### ？
&emsp;条件分岐キーワードです。内部レジスタの値が0なら、続く1キーワードまたはブロックをスキップします。その後内部レジスタの値を論理NOTします。

#### ｛
&emsp;ブロック開始キーワードです。内部レジスタの値をループカウンタにセットし、カレントポインタをループ開始ポインタにセットします。

#### ｝
&emsp;ブロック終了キーワードです。次のように処理します。（count:ループカウンタ）

	if ( count ) {
	    if( count == -1 || --count ) {
 		<ループ開始ポインタへジャンプ>
	    }
	}

#### ＞？
&emsp;多重分岐キーワードです。内部レジスタの値がnの時、続くブロック内でn番目のキーワードまたはブロックを実行します。実行後、および該当する項目がない場合は、ブロックの次のキーワードから実行します。

#### （式） ？ 〈true〉 ？ 〈false〉
&emsp;条件文です。(式)の値が真（0でない）なら 〈true〉 を、偽（0）なら 〈false〉を実行します。〈true〉,〈false〉はキーワードまたはブロックです。<br>　〈true〉の内部で(式)を記述すると内部レジスタを再設定してしまい、続く〈false〉が正常にスキップしません。この場合は、次のように〈true〉文の最後で(0)を評価してください。

	(式)? { <true> (0)} ? { <false> }

#### （式）｛...｝
&emsp;ループ文です。(式)の値回数、ブロックを実行します。式の値が0の場合でも、1回だけ実行します。(-1){...}は無限ループとなります。


#### （式）＞？｛ 〈if0〉 〈if1〉 〈if2〉 ... ｝
&emsp;多重分岐文です。(式)の値が n の場合、〈ifn〉を実行します。〈ifn〉は、キーワードまたはブロックです。

#### ★（式）＞！｛ c0 〈if0〉 c1 〈if1〉  c2 〈if2〉 ... ｝
&emsp;case文です。(式)の値が文字cnの場合、〈ifn〉を実行します。「VZFL.DEF」のメニュー処理に使用しています。



## １１.３ 演算式

&emsp;演算式は、定数、変数、演算子で構成されます。
### ■ 定数
&emsp;定数と#### して、10進数、16進数、文字定数、文字列、コマンドコードが使用できます。

	10進数			10  32767  -1  
	16進数			$0D  $8140
	文字定数			'A'  'あ'
	文字列			"string"  "文字列"
	コマンドコード	#70 #m

- 定数は、int（2バイト）で表します。
- 文字列は、終端の「"」を0に変換して、バッファに格納します。文字列の値は、先頭文字のアドレスです。
- コマンドコードは、コマンド番号に256を加えた値です。
### ■ 変数
&emsp;変数は、1または2文字の英字（大／小文字は区別しない）で表します。汎用変数、汎用フラグ、オプション変数、システム変数に分類されます。
### ■ 汎用変数
&emsp;汎用変数として、次のものが使用できます。
- r,s を除く a ～ y
- rr,ss を除く aa ～ yy	（★w,ww も汎用変数として使えます）
- ax,bx,cx,dx,si,di （割り込み処理関数での受け渡し変数として使用）

&emsp;いずれも int型（2バイト）です。起動時にはすべて0で初期化しています。マクロ実行時には初期化することはありません。
### ■ 汎用フラグ
&emsp;汎用フラグとして、fa,fb,fc,fd,★fi,★fj,fx,fy が使用できます。汎用フラグは、オプションのスイッチと同様に、0（偽）または1（真）の値をとります。起動時はすべて0（偽）です。
### ■ オプション変数
&emsp;起動時オプションも、演算式で他の変数と同様に使用できます。ただし、実行中に変更可能なオプション以外のものは、値を変更してはなりません。
### ■ システム変数
&emsp;エディタ内部の種々の状態を、システム変数で参照、変更することができます。
各システム変数は、「11.7　システム変数」で説明します。
### ■ 演算子
&emsp;演算子は、単項演算子、二項演算子、代入演算子に分類できます。
### ■　単項演算子 「+ - [** **] ++ -- ~ ! !!」

	a+   ･･････ a=1
	a-   ･･････ a=0
	-a   ･･････ -a
	a[   ･･････ push a （a をマクロスタックに push します）
	a]   ･･････ pop a  （a をマクロスタックから pop します）
	a++  ･･････ a=a+1
	a--  ･･････ a=a-1
	a~   ･･････ a=~a
	a!   ･･････ a=!a
	a!!  ･･････ a=swaphl(a) （上位バイトと下位バイトの交換）

●前置の単項演算子は、「-」（マイナス）のみです。その他は全て後置（変数の後ろ）で記述しなければなりません。そのため、<br>

	++i  !(fa && fb)

というような記述はできません。

●マクロスタックは、オプション***Bu***で確保したマクロ配列領域の最後尾から使われます。<br>
### ■　二項演算子 「.. . << >> & ^ | * / % + - < <= > >= == != && ^^ ||」

*	p.i  ･･････ p[**i**] (char *p) （byte ptr 演算子）
*	p..i ･･････ p[**i**] (int  *p) （word ptr 演算子）

※ ★Ver1.6で「i」の値の制限はなくなりました<br>
※ アクセスするセグメントは、「dz」です。<br>
### ■　代入演算子 「= &= ^= |= *= /= %= += -= ★[=」

※ ★Ver1.6で「[=」（push後代入）が追加されました。<br>

### ■ 演算子の優先順位
&emsp;上記の演算子は、上にあげた順に、より高い優先順位を持ちます。すなわち、通常の算術規則と異なり、「+」と「-」では「+」の方が優先順位が高くなります。これは、内部処理の簡略化の結果です。



## １１.４ システム関数

#### ＆a("message") ＆a(sysmsg) 　 (Ask)
&emsp;画面の最下行に

	messge か？ (Y/N) 

と表示し、問い合せします。<br>　文字列の代わりにシステムメッセージNo.を与えると、VZの内部メッセージを表示します。

［返り値］r == 1　　: [**Y**]<br>
&emsp;　　　　r == 0　　: [**N**]<br>
&emsp;　　　　r == -1　 : [**ESC**]<br>

	［例］	&a("編集テキストを放棄します")

#### ＆b(time)　 (Beep)
&emsp;一定時間ビープ音を鳴らします。

［返り値］　なし（rは保存）<br>

	［例］	&b(60)		; 約1秒間ビープ音を鳴らします。

#### ＆c　 (Char)
&emsp;キーボードから1文字入力します。

［返り値］　なし（rは破壊）<br>

	［例］	:A (s)?{ &c >A }	; 編集モードに戻るまでキー入力します。

#### ＆d　 (Display)
&emsp;サイレントフラグをOFFし、全画面を再表示します。

［返り値］　なし（rは保存）<br>

#### ＆e(ptr)　 (Extern)
&emsp;「ptr」が示す文字列をマクロコードとしてコールします。

［返り値］　マクロコードの実行結果

	［例］	&g("【マクロ文】") &e(pw)

#### ＆f(c,str)　 (Find)
&emsp;文字「c」を文字列「str」内でサーチし、見つかった位置を返します。半角と全角文字が混在していても構いません。

［返り値］　r >= 0　　: 見つかった位置までの文字数<br>
&emsp;　　　　　r == -1　　: 見つからない<br>

	［例］	&f(cd,"{}()[]<>")

#### ★＆g(ttl[,wd][,str]) 　 (Get string)
&emsp;「<ttl>」ウィンドウを開き、文字列を入力します。入力した文字列は、変数「pw」が示すワークバッファに格納します。入力可能な文字列の長さは、63文字です。<br>　入力した文字列が定数ならば、その値を返します。

● **Ver1.6では「wd」でウィンドウサイズ、「str」で初期文字列が設定できます。**<br>

［返り値］　r == 0　　: 入力した文字列は、定数ではない<br>
&emsp;　　　　　r == -1　　: [**ESC**]<br>
&emsp;　　　　　r == -2　　:⏎のみ<br>
&emsp;　　　　　上記以外: 入力した文字列が表す数値<br>

	［例］	&g("文字色") an=r, &d

#### ＆h　 (Hexa)
&emsp;カーソル位置以降の文字列を16進数とみなして読み込み、その値を返します。
［返り値］	r == -1	: 16進数ではない

#### ＆i(n) ＆i(code)　 (Interrupt)
&emsp;　　　　n < 256　　: 内部割り込みn番を実行します。<br>
&emsp;　　　　code > 256　: codeをマシン語命令とみなしてコールします。<br>
&emsp;受渡しレジスタとして、変数「ax,bx,cx,dx,si,di」を使用します。また、「CS,DS,ES」にはVZのコードセグメントをセットします。

［返り値］　キャリーフラグ

	［例］	ax=$2C00, &i($21) rn=cx+dx,
 			&i("$(FD,F3,A4,FC,C3)")		;std; repz movsb; cld; ret

#### ＆j(n)　 (Japanese)
 nで指定した値によって、日本語FEPを制御する。ON時に設定する値は、オプション「FR」にセットする値と同じ。<br>　　　　　n == 0　　 : FEPをOFF<br>
&emsp;　　　　n == -1　　: FEPをOFFの前の状態に戻す<br>
&emsp;　　　　n > 0　　　: FEPを強制的にONする<br>

［返り値］　なし（rは保存）

#### ＆k　 (Keyin)
&emsp;BIOSのキー入力をコールします。キー入力があった場合は、最初のキーを取り込み、残りは捨てます。

［返り値］　r == 0　　: キー入力なし<br>
&emsp;　　　　　r != 0　　 : 入力キーコード（特殊キーの場合、上位バイトにスキャンコード）<br>

#### ＆l　 (Line in)
&emsp;⏎または[**ESC**]が入力されるまで、キーボードから入力します。

［返り値］　なし（rは破壊）

	［例］	#J &o('0'+r) &l

#### ＆m("<format>",par1,par2..) 　 (Message)
&emsp;printf文に準じた書式制御で、画面最下行へメッセージを出力します。
<format>の書式制御文字は、次のとおりです。<br>
&emsp;　　　%[-][**0**][**n**][,][**l**]{d|u|x|c|s}<br>

［返り値］　なし（rは保存）

	［例］	&m("Result: %d %u $%x '%c' $"%16s$"",r,r,r,r,r)

#### ＆？("<format>",par1,par2..)　 (printf)
&emsp;printf文に準じた書式制御で、カーソル位置へ出力します。

［返り値］　なし（rは破壊）

#### ＆n　 (Numeric)
&emsp;カーソル位置以降の文字列を10進数とみなして読み込み、その値を返します。

［返り値］　r == -1　　: 10進数ではない

#### ＆o(code)　 (Output)
&emsp;「code」をキーボードからの入力文字またはコマンドとして入力します。＆p関数からの入力を返す時に使用します。

［返り値］　なし（rは破壊）

#### ＆p　 (Pause)
&emsp;キーボードから文字またはコマンドを入力し、そのコードを返します。

［返り値］　r < $FF　　: 入力文字コード<br>
&emsp;　　　　　r >= $100　　: コマンドコード （コマンド番号＋256、#nn 定数に対応）

	［例］	(-1){ &p (r > $FF)? &o }  ; 文字の入力のみ無視する。

#### ＆q　 (Quit)
&emsp;サブルーチン（マクロ）コールのネストを1レベルスキップします。

［返り値］　なし（rは保存）

#### ＆r　 (Random)
&emsp;乱数を発生させ、その値を返します。

［返り値］　r = rand()

#### ＆s　 (Silent)
&emsp;「サイレントフラグ」をオンし、それ以降の画面出力を停止します。＆m(...)によるメッセージは表示されます。

［返り値］　なし（rは保存）

#### ＆t　 (Trace)
&emsp;マクロの実行を中断し、トレースモードに入ります。ファンクションキー表示の左端に、中断した位置のマクロコードの一部を表示し、次のキーの入力待ちになります。<br>　　　　　[**Space**]　: ステップ実行<br>
&emsp;　　　　⏎　　: マクロの連続実行を再開<br>
&emsp;　　　　[**ESC**]　　: マクロ実行の中止<br>
[**STOP**]キー（J-3100版、IBMPC版では[**Ctrl**]+[**Break**]）を押してもトレースモードに入ります。

［返り値］　なし（rは保存）

#### ＆u(c)　 (Upper)
&emsp;文字「c」が小文字ならば大文字に変換し、その値を返します。

［返り値］　r = toupper(c)

#### ＆v(mode)　 (Video)
&emsp;カーソル表示をON／OFFします。<br>　　　　　mode	: 0 = OFF， 1 = ON

［返り値］　なし（rは保存）

#### ＆w(time)　 (Wait)
&emsp;一定時間ウェイトします。

［返り値］　なし（rは保存）

	［例］	&w(60)	; 約1秒間ウェイトします。

#### ＆x(x)　 (locate X)
&emsp;カーソルを「xカラム」へ移動します。

［返り値］　なし（rは破壊）

#### ＆y(y)　 (locate Y)
&emsp;カーソルを画面の上端から「Y行目」に移動します。

［返り値］　なし（rは破壊）

#### ★＆z(file[,n])　 (load macro)
&emsp;外部マクロファイル「file」をロードし、マクロバッファへ組み込みます。同じモジュール名のマクロが既にマクロバッファに存在する場合は、上書きします。マクロバッファが足りない場合は、先頭の外部マクロから削除して、再読み込みします。

［返り値］　r == 0　 : 正常終了<br>
&emsp;　　　　　r != 0　　: エラー<br>

#### ★＆＾　 (reset option)
&emsp;オプションを初期化します。



## １１.５ 拡張システム関数

&emsp;以下の拡張システム関数が、Ver1.6で新たに追加されました。

● **返り値rの記述がないものについては、rは保存されます。**<br>
### ■ 文字列操作関数

#### ＆Sm(q,p,n)　 (Memcpy)
&emsp;ポインタpからqへnバイトコピーします。

#### ＆Sc(q,p[,n])　 (strCpy)
&emsp;文字列pをポインタqへ[最大nバイト]コピーします。

［返り値］　r = コピー先の末尾ポインタ

#### ＆Sa(q,p[,n])　 (strcat)
&emsp;文字列pを文字列qの後ろへ連結します。

［返り値］　r = コピー先の末尾ポインタ

#### ＆Sx(p,q)　 (strcmp)
&emsp;文字列pと文字列qを比較します。

［返り値］　r = 0:一致、1:不一致

#### ＆Si(p,q)　 (strIcmp)
&emsp;文字列pと文字列qをIgnore Caseで比較します。

［返り値］　r = 0:一致、1:不一致

#### ＆Sf(p,c)　 (strchr)
&emsp;文字列pの中で文字cをサーチします。（全角対応）

［返り値］　r == 0　　: 見つからない<br>
&emsp;　　　　　r != 0　　: cを指すポインタ

#### ＆So(p,q)　 (strstr)
&emsp;文字列pの中で文字列qをIgnore Caseでサーチします。

［返り値］　r == 0　　: 見つからない<br>
&emsp;　　　　　r != 0　　: pを指すポインタ

#### ＆Su(p)　 (strUpr)
&emsp;文字列pの英小文字を大文字に変換

#### ＆Sl(p)　 (strLwr)
&emsp;文字列pの英大文字を小文字に変換します。

#### ＆Sn(p)　 (strlen)
&emsp;文字列pの長さを返します。（終端の0は含みません）

［返り値］　r = pの長さ

#### ＆Sw(p)　 (Wordlen)
&emsp;文字列pのスペース,TABまでの文字数をカウントします。

［返り値］　r = 文字数

#### ＆Ss(p)　 (skipSpace)
&emsp;ポインタpからスペース,TABをスキップ

［返り値］　r = 次の文字のポインタ

#### ＆Sh(q,p[,1])　 (Histcpy)
&emsp;文字列pをヒストリーバッファqへ格納します。[,1]指定時は、ファイルクローズ時と同様に、格納します。

#### ＆Se(q,p)　 (getEnv)
&emsp;環境変数pの設定文字列を、ポインタqへ格納します。

［返り値］　r == 0　　: 環境変数が見つからない
&emsp;　　　　　r != 0　　: コピー先の末尾ポインタ

#### ＆Sy(p)　 (parsepath)
 パス名pを解析します。

［返り値］　r = 解析結果<br>
&emsp;　　　　　　　+1 : ワイルドーカード文字<br>
&emsp;　　　　　　　+2 : 拡張子<br>
&emsp;　　　　　　　+4 : ファイル名<br>
&emsp;　　　　　　　+8 : ディレクトリ名<br>
&emsp;　　　　　　　+16: ドライブ名<br>
&emsp;　　　　　　　+32: 絶対パス<br>
&emsp;　　　　　bx = ファイル名の開始位置<br>
&emsp;　　　　　cx = 拡張子の開始位置<br>
&emsp;　　　　　si = パス名の末尾<br>

#### ＆Sp(q,p,..)　 (sprintf)
&emsp;書式pの出力をポインタqへ格納します。


### ■ ファイラー操作関数

#### ＆Fl(p)　 (fiLer)
&emsp;パスマスクpでファイラーを起動します。起動後ただちにマクロの次の命令が実行されますので、編集モードまで待機する時は、＆Cr を実行します。

［返り値］　r = 0　　: ⏎<br>
&emsp;　　　　　r = -1　　: [**ESC**]

#### ＆Fm(c)　 (filer Menu)
&emsp;文字cをメニューバー内でサーチします。

［返り値］　r >= 0　　: r番目のメニュー<br>
&emsp;　　　　　r = -1　　: 見つからない

#### ＆Fg(q[,1])　 (Get pool)
&emsp;ファイラーで選択されたファイル名を、ポインタqへ格納します。[,1]指定時は、常にフルパスで格納します。この命令は、＆Fl実行後にコールします。

［返り値］　r = ファイルの属性

#### ＆Fn　 (next pool)
&emsp;選択された次のファイルを探します。＆Fgとペアで使います。

［返り値］　r = 0　　: これ以上選択ファイルがない<br>
&emsp;　　　　　r = 1　　: 次のファイルを選択

### ■ ロング演算関数

#### ＆Le(p,q)　 (Long Equ)
#### ＆La(p,q)　 (Long Add)
#### ＆Ls(p,q)　 (Long Sub)
#### ＆Lc(p,q)　 (Long Cmp)
&emsp;ポインタpとポインタqの示すロング整数を演算します。


#### ＆Ia(p,n)　 (Int Add)
#### ＆Is(p,n)　 (Int Sub)
#### ＆Im(p,n)　 (Int Mul)
#### ＆Id(p,n)　 (Int Div)
&emsp;ポインタpの示すロング整数に、nを演算します。

### ■ その他の関数

#### ＆Cr
&emsp;編集モードになるまで、マクロの実行を停止します。

#### ＆Zd(n)
&emsp;指定マクロモジュールを削除します。<br>　　　　n = モジュール番号 or モジュール名ポインタ

#### ＆Zs(p[,n])
&emsp;指定モジュールをサーチします。

［返り値］　r == 0　　: 見つからない<br>
&emsp;　　　　　r != 0　　: 見つかった



## １１.６ コマンド関数

#### ＆＃35(n)　＆＃r(n)　 ページアップ
&emsp;「n」行スクロールアップします。

#### ＆＃36(n)　＆＃c(n)　 ページダウン
&emsp;「n」行スクロールダウンします。

#### ＆＃42(0)　＆＃＿(0)　 ファイルの最後
&emsp;ファイルの最後へジャンプします。

#### ＆＃43(n)　＆＃U(n)　 直前のカーソル位置
&emsp;「マーク#n」へカーソルを移動します。（n=0～4）

#### ＆＃44(n)　＆＃M(n)　 カーソル位置マーク
&emsp;カーソル位置を「マーク#n」に記憶します。（n=0～4）

#### ＆＃45(n)　＆＃J(n)　 指定行番号ジャンプ
&emsp;「行番号n」へカーソルを移動します。

#### ＆＃51(p)　 テキストスタッククリア
&emsp;テキストスタックのエンドをpに変更します。

#### ＆＃63(n)　＆＃T(n)　 編集テキスト切替え
&emsp;編集テキストをn番に切り替えます。

#### ＆＃64(n)　＆＃Y(n) 割モード切替え
&emsp;画面の分割モードを変更します。<br>
&emsp;　　　n　: 0 = フル，2 = 横分割，4 = 縦分割

#### ＆＃68(n)　 スペース・タブの挿入
&emsp;カーソル位置から「カラムn」までの間を半角スペースまたはTABで埋めます。TABを使わない時は、マクロの中でオプション***Eu***を「+」にしてください。この関数は矩形ブロックやセンタリングのマクロで使用しています。

#### ★＆＃80(n)　 モジュールの組み込み
&emsp;編集テキストを外部マクロとみなしてマクロバッファへ組み込みます。＃80コマンドのモジュール対応版です。nは、組み込み後実行したいマクロの相対番号です。

#### ＃？
&emsp;「サイレントフラグ」をOFFし、カーソル行を再表示します。

#### ＃］
&emsp;ステータスラインを再表示します。

#### ＃03 ＃［
&emsp;エディタを強制終了します。


## １１.７ システム変数

&emsp;マクロの演算式で使用できるシステム変数の一覧です。
- 英大文字と小文字は識別しません。
- 「*」がついているものは、実行中に変更可能です。
- Ver1.6で追加／変更された変数は、網掛けで示してあります。
### ■ グローバル変数
|変数|内容|
|---|---|
|***cm*** *|直前に実行したエディットコマンド番号|
|***ef***|EMSのフリーページ数|
|***ep***|編集モード時の[**ESC**]の扱い<br>　　-　: プリフィックスキー<br>　　+	　: エスケープキー|
|***ks***|シフトキーフラグ<br>（98版）<br>　　+1:[**SHIFT**] +2:[**CAPS**] +4[ｶﾅ] +8:[**GRPH**] +16:[**CTRL**]<br>（IBM版）<br>　　+1:[**Shift**] +2 左[**Shift**] +4:[**Ctrl**] +8[**Alt**]|
|***mb*** *|ブロックモード<br>　　0: 非ブロックモード<br>　　1: 行境界のブロックモード<br>　　2: 文字境界のブロックモード<br>　　4: 矩形ブロックモード|
|***mi*** *|挿入モード<br>　　0: 挿入モード（Insert）<br>　　1: 上書モード（Overwrite）<br>　　★2: 桁対応上書モード|
|***mp*** *|ページングモード<br>　　0: ［P］表示ページングモード<br>　　1: ［C］論理ページングモード<br>　　2: ［S］文字列検索モード|
|***r*** *|コマンド、マクロ、メニュー等の返り値|
|***rn*** *|乱数用ワーク（seed）|
|***s***|システムモード<br>　　0: 編集モード<br>　　1: 文字列入力モード<br>　　2: コマンドラインモード<br>　　3: ファイラーモード<br>　　4: メニュー,(Y/N)等の1文字入力モード|
|***vp***|画面出力制御パラメータブロック<br>　　..0: カーソル位置のoffset<br>　　..2: カーソル位置のsegment<br>　　.4	: 表示ウィンドウ（開始x,y,サイズx,y）<br>　　.8: カーソル位置（x,y）<br>　　.10: DOSのカーソル位置（x,y）<br>　　.12: 表示属性|
|***wa***|Active windwos record pointer|
|***wb***|Back |
|***wf***|Free|
|***wo***|Opened|
|***wc***|編集中のテキストの数（コンソールファイルは除く）|
|***wh*** *|編集画面の横分割位置	|
|***wv*** *|編集画面の縦分割位置|

★ 以降はVer1.6で追加されたグローバル変数
|変数|内容|
|---|---|
|***ic***|最後に入力された文字コード（0=コマンドキー）|
|***fg***|グローバルファイラーワークポインタ<br>　　.0: ディレクトリの表示数（0=single, 1=dual）<br>　　.1: 参照パス／マスクの初期化<br>　　..2: 最後に実行されたファイラーコマンド|
|***fh***|ファイラーのMaskメニューの選択bit|
|***fl***|カレントファイラーワーク構造体のポインタ|
|***mg***|マクロ制御用ワークポインタ<br>　　..0: 内部レジスタ<br>　　..2: 実行中のマクロモジュールのヘッダアドレス<br>　　..4: 実行中のマクロのネストポインタ<br>　　..6: イベントマクロ実行前のネストポインタ<br>　　..8: ループカウンタ<br>　　..10: ループの先頭ポインタ<br>　　mg+16: ネスト用ワーク（8バイト×16個）|
|***mh***|先頭のモジュールヘッダアドレス|
|***mx*** *|&pでのマクロ実行、イベントマクロの実行禁止|
|***ux*** *|文字、行・ブロック削除時のバッファへの格納禁止|
|***sm***|ベースモード<br>　　0: 編集モード<br>　　2: コマンドラインモード<br>　　3: ファイラーモード|
|***ss*** *|サイレントフラグ<br>　　+1: 通常のサイレントモード（&s）<br>　　+2: DOSコマンドラインもサイレント|
|***Jd***|Dl Dc Dt De Dr Dj Ds Db Dn Du Df Dp Dg Dh Dv|
|***Je***|Ei Es Ez Eb Eu Ek Et Eh Ec Ew Ex En Ev Ea El Ej|
|***Js***|Sx Se Sd Sk Eo Sy YN Sn Sq FP Sb RO Sz|
|***Jx***|ep zk FQ ux mx VW ZH RX FK St|
|***Ju***|fa fb fc fd fi fj fx fy|
### ■ 編集テキスト変数
|変数|内容|
|---|---|
|***cd***|カーソル位置の文字コード|
|***ck***|カーソル位置の文字種（0:半角、1:全角）|
|***cl***|カーソル行の先頭オフセット|
|***cp***|カーソル位置のオフセット|
|***ct***|カーソル位置の文字タイプ<br>　　0: EOF<br>　　1: 改行<br>　　2: 00h～20h、全角スペース<br>　　3: 半角記号・全角記号<br>　　4: ひらがな<br>　　5: 上記以外の全角文字<br>　　6: 上記以外の半角文字|
|***fe***|編集テキストの拡張子タイプ<br>（デフォルトテキスト拡張子の何番目か）|
|***ht*** *|編集テキストのタブカラム数|
|***id***|テキストID|
|***kx*** *|保存したカーソルのカラム位置|
|***ky*** *|保存したカーソルのウィンドウ内の行（Y）位置|
|***ld***|表示行番号|
|***lh***|カーソル位置の論理行の先頭からのY位置|
|***ln***|論理行番号|
|***lx*** *|表示カーソルのカラム位置|
|***ly***|表示カーソルのウィンドウ内のY位置|
|***mr*** *|テキスト修正フラグ<br>　　0: 未修正<br>　　1: 修正あり<br>　　254: Read Only（修正あり）<br>　　255: Read Only（修正なし）<br>　　$80: View mode|
|***we*** *|編集テキストの表示カラム数|
|***wn***|編集テキスト番号（ファイル名の前の数字）|
|***wt*** *|画面分割モード<br>　　0: 全画面<br>　　2: 横分割の上<br>　　3: 横分割の下<br>　　4: 縦分割の左<br>　　5: 縦分割の右|
|***wx***|編集ウインドウの横幅|
|***wy***|編集ウインドウの高さ|
|***xb***|ブロックマーカーのカラム位置|
|***zk***|EZKEYの存在（0:なし、1:あり）|
|★***vw***|VWXの存在（0:なし、1:あり）|
|★***ts***|タイトルサーチ文字列ポインタ|
|★***qn***|編集モードでの入力文字カウンタ|
|★***qk***|!Editイベント用入力文字テーブル|
|★***xc***|ブロック範囲比較変数<br>　　-1: cp <  tblkp<br>　　0: cp == tblkp<br>　　1: cp >  tblkp|
### ■ ポインタ変数
|変数|内容|
|---|---|
|***pa***|アプリケーションヒストリーバッファ|
|***pc***|VZの起動コマンド名|
|***pd***|カレントディレクトリ名|
|***pf***|ファイル名ヒストリーバッファ|
|***pi***|DEFファイルの参照パス名|
|***pn***|カレントドライブ名|
|***pq***|テンポラリファイルの参照パス名|
|***ps***|検索文字列ヒストリーバッファ|
|***pu***|マクロ配列領域の先頭|
|***pw***|ワーク用ヒストリーバッファ|
|***px***|コマンドラインヒストリーバッファ|
|***pz***|コマンド起動パス名|
|***sp***|マクロスタックポインタ|
|★***pe***|editfileのファイル名ポインタ|
|★***pm***|選択したメニューのメッセージポインタ|
|★***pr***|リネーム時の一時ワーク（64byte）|
|★***pt***|タイトルサーチ文字列バッファ（64byte）|
### ■ セグメント変数
|変数|内容|
|---|---|
|★***cz***,***gz***|スタックセグメント|
|★***vz***|VZ.COMのコードセグメント|
|***dz*** *|データセグメント（ポインタ演算で使用）|
|***tz***|編集テキストバッファのセグメント|
|***kz***|テキストスタックのセグメント|
|***kp***|テキストスタックエンドオフセット|



